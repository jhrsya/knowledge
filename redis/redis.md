# redis

## SQL和NoSQL
SQL: 结构化数据，一开始要对表结构定义好，且不建议对表结构进行修改
NoSQL: 非结构化数据，redis是键值型数据库。还有文档型数据库，是json文档。图类型数据库

| --- | SQL | NoSQL |
| :--: | :--: | :--: |
| 数据结构 | 结构化 | 非结构化 |
| 数据关联 | 关联的 | 无关联的 |
| 查询方式 | SQL查询 | 非SQL |
| 事物特性 | ACID | BASE |
| 存储方式 | 磁盘 | 内存 |
| 扩展性 | 垂直 | 水平 |

使用场景：
- SQL: 数据结构固定，相关业务对数据安全性、一致性要求较高。
- NoSQL: 数据结构不固定，对安全性、一致性要求不高，对性能要求较高。

## redis 特征
1. 键值型(key-value)，value支持多种不同数据结构，功能丰富。
2. 单线程，每个命令局具备原子性。
3. 低延迟，速度快(基于内存、IO多路复用、良好的编码)
4. 支持数据持久化
5. 支持主从集群和分片集群
6. 支持多语言客户端


## redis 数据结构
![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304121252287.png)

## redis 通用命令
![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304121305949.png)

## session共享问题
多台tomcat无法共享session存储空间，当请求切换到不同tomcat时导致数据丢失的问题。

session的替代方案应该满足：
- 数据共享
- 内存存储
- key、value结构


## 缓存的作用和成本
缓存的作用：
- 降低后端负载
- 提高读写效率，降低响应时间


缓存的成本：
- 数据一致性成本
- 代码维护成本
- 运维成本

## Redis缓存更新策略
![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131321236.png)


缓存更新最佳方案：
![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131337216.png)


## 缓存穿透
缓存穿透是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库上。

常见的解决思路有：
- 缓存空对象
    - 优点：实现简单，维护方便
    - 缺点：
        - 额外的内存消耗：每个不存在的id都对应一个null值
        - 可能造成短期的不一致：数据库新增数据id，但是缓存中还是null值
- 布隆过滤
    - 优点：内存占用少，没有多余的key
    - 缺点：
        - 实现复杂
        - 存在误判可能
- 增加id的复杂度，避免被猜测id的规律
- 做好基础数据的参数格式校验
- 加强用户权限管理
- 做好热点参数的限流


![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131645799.png)


## 缓存雪崩
缓存雪崩是指同一时间段内大量的缓存的Key同时失效，或者Redis服务器宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：
- 给不同key的TLL添加随机值
- 利用redis集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

## 缓存击穿
缓存击穿问题又叫热点Key问题，就是一个被高并发访问且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见解决方案:
- 互斥锁(强调一致性)
- 逻辑过期(强调可用性)

![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131723811.png)

![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131729338.png)


![](https://fvector.oss-cn-hangzhou.aliyuncs.com/202304131730397.png)

