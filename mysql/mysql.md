## 1. 什么是mvcc?
多版本并发控制。
在MVCC模型中，每个数据库事务都可以看到一个独立的版本，而不是操作共享的原始数据。当多个事务同时访问同一行数据时，MVCC会创建多个版本的数据，每个版本都对应着不同的事务，每个事务都可以看到自己的版本。这些版本通过时间戳或其他标识符进行标记，以便数据库系统可以识别哪个版本是每个事务的快照。

由于每个事务都只访问自己的版本，因此不同的事务可以并发地读取和写入数据库，而不会相互干扰。这种并发控制技术可以提高数据库系统的性能和并发性，同时保证数据的一致性和隔离性。

快照读是通过mvcc来实现的。

## 锁的概念
独占锁（写锁）(X锁)，共享锁（读锁）(S锁)。

表级别锁有：
- 表锁
- 元数据锁(MDL)：不需要显示的使用MDL，当我们对数据库表进行操作时，会自动给这个表加上MDL。
- 意向锁
- AUTO-INC锁

行级别锁有：
- Record Lock: 记录锁，也就是仅仅把一条记录锁上；
- Gap Lock: 间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock: Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
- 插入意向锁
InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。


### MDL（表结构）
元数据锁(MDL)：不需要显示的使用MDL，当我们对数据库表进行操作时，会自动给这个表加上MDL。
MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。
- 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
- 对一张表做结构变更操作的时候，加的是 MDL 写锁；

MDL作用：
MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

### 意向锁
意向锁的目的是为了快速判断表里是否有记录被加锁。
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

### AUTO-INC锁
表里的主键通常都会设置成自增的，这是通过对主键字段声明 AUTO_INCREMENT 属性实现的。

之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 AUTO-INC 锁实现的。

AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放。

### Record Lock
Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S （共享）锁和 X （独占）锁之分的：
- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

### Gap Lock
Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。


### Next-Key Lock
Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。

比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。

虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。

### 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。
当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），此时事务 B 就会发生阻塞，直到事务 A 提交了事务。

插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁。

如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。


## CRUD操作和表结构修改的区别是什么？
CRUD是指创建（Create）、读取（Retrieve）、更新（Update）和删除（Delete）这四种基本数据库操作，用于操作数据库中的数据记录。

而表结构修改是指对数据库表的结构进行变更，包括添加、删除、修改表的列、修改列的数据类型等操作。这些操作不是对表中的具体数据记录进行修改，而是对表本身的结构进行变更。

虽然CRUD操作和表结构修改都是对数据库进行操作，但它们的目的和范围不同。CRUD操作是对具体数据记录进行操作，目的是添加、查询、更新或删除具体的数据记录。而表结构修改是对表本身的结构进行变更，目的是更改表的结构以适应业务需求或优化数据库性能。

需要注意的是，在进行表结构修改时，需要谨慎操作，避免数据的丢失或出现不可预期的问题。同时，需要在修改前备份数据库，以便在出现问题时可以恢复到修改之前的状态。


## 事务

开启事务：
`START TRANSACTION;`

回滚事务：
`ROLLBACK;`

提交事务：
`COMMIT;`

## mysql是怎么加行级别锁的？


## mysql中的悲观锁和乐观锁？
MySQL 中的乐观锁和悲观锁是一种基于并发控制的方式，而 Record Lock、Gap Lock 和 Next-Key Lock 是 InnoDB 存储引擎使用的锁机制。

乐观锁和悲观锁：
- 乐观锁假设并发访问的数据不会发生冲突，只有在提交更新时才会检查并发冲突。在 MySQL 中，乐观锁可以通过使用版本号或时间戳来实现，例如使用 SELECT ... FOR UPDATE 或者 SELECT ... FOR SHARE 等语句。
- 悲观锁则是假设并发访问的数据会发生冲突，因此在读取和更新数据时都会加锁，保证只有一个事务可以访问数据。在 MySQL 中，悲观锁可以使用 SELECT ... FOR UPDATE 或者 SELECT ... LOCK IN SHARE MODE 语句来实现。



